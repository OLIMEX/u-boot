Author: Rabeeh Khoury <rabeeh@solid-run.com>
Description: SPL SATA support
 Taken from https://github.com/rabeeh/u-boot-imx6.git

diff --git a/common/Makefile b/common/Makefile
index d12cba5..a60856a 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -42,6 +42,8 @@ obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
 obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
 obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
+obj-$(CONFIG_ENV_IS_IN_SATA) += env_sata.o
+obj-$(CONFIG_ENV_IS_IN_BOOT_DEVICE) += env_bootdevice.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index 5bcc324..61e9cec 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -47,6 +47,8 @@ DECLARE_GLOBAL_DATA_PTR;
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_IN_UBI)		&& \
+	!defined(CONFIG_ENV_IS_IN_SATA)         && \
+	!defined(CONFIG_ENV_IS_IN_BOOT_DEVICE)  && \
 	!defined(CONFIG_ENV_IS_NOWHERE)
 # error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|ONENAND|\
 SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
diff --git a/common/cmd_sata.c b/common/cmd_sata.c
index fc92131..b729b88 100644
--- a/common/cmd_sata.c
+++ b/common/cmd_sata.c
@@ -15,7 +15,7 @@
 #include <part.h>
 #include <sata.h>
 
-static int sata_curr_device = -1;
+int sata_curr_device = -1;
 block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
 
 int __sata_initialize(void)
diff --git a/common/env_sata.c b/common/env_sata.c
new file mode 100644
index 0000000..31c479d
--- /dev/null
+++ b/common/env_sata.c
@@ -0,0 +1,170 @@
+/*
+ * (C) Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <sata.h>
+#include <search.h>
+#include <errno.h>
+
+#if defined(CONFIG_ENV_SIZE_REDUND) &&  \
+	(CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
+#error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
+#endif
+
+char *env_name_spec = "SATA";
+
+#ifdef ENV_IS_EMBEDDED
+env_t *env_ptr = &environment;
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr;
+#endif /* ENV_IS_EMBEDDED */
+
+extern int sata_curr_device;
+
+#if !defined(CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_OFFSET 0
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int env_init(void)
+{
+	/* use default */
+	gd->env_addr = (ulong)&default_environment[0];
+	gd->env_valid = 1;
+
+	return 0;
+}
+
+
+inline int write_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_write(sata_curr_device, blk_start,
+					blk_cnt, (u_char *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+int saveenv(void)
+{
+	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
+	ssize_t	len;
+	char	*res;
+	struct block_dev_desc_t *sata = NULL;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return 1;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return 1;
+	}
+	res = (char *)&env_new->data;
+	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		return 1;
+	}
+
+	env_new->crc = crc32(0, &env_new->data[0], ENV_SIZE);	
+
+	sata = sata_get_dev(sata_curr_device);
+
+	printf("Writing to SATA(%d)... ", sata_curr_device);
+	if (write_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, (u_char *)env_new)) {
+		puts("failed\n");
+		return 1;
+	}
+
+	puts("done\n");
+
+	return 0;
+}
+
+
+inline int read_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_read(sata_curr_device, blk_start,
+					blk_cnt, (uchar *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+void env_relocate_spec(void)
+{
+#if !defined(ENV_IS_EMBEDDED)
+	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
+	struct block_dev_desc_t *sata = NULL;
+	int ret = 0;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return 1;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return 1;
+	}
+	sata = sata_get_dev(sata_curr_device);
+
+	if (read_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, buf)){
+		printf( "\r\n--->Read environment failed \r\n");
+		ret = 1;
+		goto err;
+	}
+
+	gd->env_valid = 1;
+	env_import(buf, 1);
+	ret = 0;
+err:
+	if (ret)
+		set_default_env(NULL);
+#endif
+}
+
+
+
diff --git a/common/spl/Makefile b/common/spl/Makefile
index 5c0637b..9d43357 100644
--- a/common/spl/Makefile
+++ b/common/spl/Makefile
@@ -16,4 +16,5 @@ obj-$(CONFIG_SPL_NAND_SUPPORT) += spl_nand.o
 obj-$(CONFIG_SPL_ONENAND_SUPPORT) += spl_onenand.o
 obj-$(CONFIG_SPL_NET_SUPPORT) += spl_net.o
 obj-$(CONFIG_SPL_MMC_SUPPORT) += spl_mmc.o
+obj-$(CONFIG_SPL_SATA_SUPPORT) += spl_sata.o
 endif
diff --git a/common/spl/spl.c b/common/spl/spl.c
index da31457..0e4364e 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -205,6 +205,11 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 		spl_net_load_image("usb_ether");
 		break;
 #endif
+#ifdef CONFIG_SPL_SATA_SUPPORT
+	case BOOT_DEVICE_SATA:
+		spl_sata_load_image();
+		break;
+#endif
 	default:
 		debug("SPL: Un-supported Boot Device\n");
 		hang();
diff --git a/common/spl/spl_sata.c b/common/spl/spl_sata.c
new file mode 100644
index 0000000..5f910ca
--- /dev/null
+++ b/common/spl/spl_sata.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2000-2005, DENX Software Engineering
+ *		Wolfgang Denk <wd@denx.de>
+ * Copyright (C) Procsys. All rights reserved.
+ *		Mushtaq Khan <mushtaq_k@procsys.com>
+ *			<mushtaqk_921@yahoo.co.in>
+ * Copyright (C) 2008 Freescale Semiconductor, Inc.
+ *		Dave Liu <daveliu@freescale.com>
+ * Copyright (C) 2010 Texas Instruments
+ *		Aneesh V <aneesh@ti.com>
+ * Copyright (C) 2013 TechNexion Ltd.
+ *		Richard Hu <linuxfae@technexion.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <spl.h>
+#include <fat.h>
+#include <ext4fs.h>
+#include <version.h>
+#include <part.h>
+#include <sata.h>
+
+static int sata_curr_device = -1;
+block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
+
+int sata_initialize(void)
+{
+	int rc;
+
+	memset(&sata_dev_desc[0], 0, sizeof(struct block_dev_desc));
+	sata_dev_desc[0].if_type = IF_TYPE_SATA;
+	sata_dev_desc[0].dev = 0;
+	sata_dev_desc[0].part_type = PART_TYPE_UNKNOWN;
+	sata_dev_desc[0].type = DEV_TYPE_HARDDISK;
+	sata_dev_desc[0].lba = 0;
+	sata_dev_desc[0].blksz = 512;
+	sata_dev_desc[0].log2blksz = LOG2(sata_dev_desc[0].blksz);
+	sata_dev_desc[0].block_read = sata_read;
+	sata_dev_desc[0].block_write = sata_write;
+
+	rc = init_sata(0);
+#if defined(CONFIG_SPL_FAT_SUPPORT) || defined(CONFIG_SPL_EXT_SUPPORT)
+	if (!rc) {
+		rc = scan_sata(0);
+		if (!rc && (sata_dev_desc[0].lba > 0) &&
+			(sata_dev_desc[0].blksz > 0))
+			init_part(&sata_dev_desc[0]);
+	}
+#endif
+	sata_curr_device = 0;
+	return rc;
+}
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int sata_load_image_raw(unsigned long sector)
+{
+	unsigned long err = 0;
+	u32 image_size_sectors;
+	struct image_header *header;
+	ulong n;
+	
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	n = sata_read(sata_curr_device, sector, 1, header);
+
+	/* flush cache after read */
+	flush_cache((unsigned long)header, 1 * sata_dev_desc[sata_curr_device].blksz);
+
+	if (n != 1) {
+		err = 1;
+		goto end;
+	}
+	
+	spl_parse_image_header(header);
+
+	/* convert size to sectors - round up */
+	image_size_sectors = (spl_image.size + sata_dev_desc[sata_curr_device].blksz - 1) /
+				sata_dev_desc[sata_curr_device].blksz;
+
+	printf("\nSATA read: device %d block # %ld, count %ld ... ",
+	sata_curr_device, sector, image_size_sectors);
+
+	n = sata_read(sata_curr_device, sector, image_size_sectors, (void *)spl_image.load_addr);
+
+	/* flush cache after read */
+	flush_cache((void *)spl_image.load_addr, image_size_sectors * sata_dev_desc[sata_curr_device].blksz);
+
+	printf("%ld blocks read: %s\n", n, (n==image_size_sectors) ? "OK" : "ERROR");
+	if (n != image_size_sectors) {
+		err = 1;
+		goto end;
+	}
+
+end:
+	if (err == 1)
+		printf("spl: SATA blk read err - %lu\n", err);
+
+	return err;
+}
+
+#ifdef CONFIG_SPL_FAT_SUPPORT
+static int sata_load_image_fat(const char *filename)
+{
+	int err;
+	struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+
+	err = file_fat_read(filename, header, sizeof(struct image_header));
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	err = file_fat_read(filename, (u8 *)spl_image.load_addr, 0);
+
+end:
+	if (err <= 0)
+		printf("spl: error reading image %s, err - %d\n",
+		       filename, err);
+
+	return (err <= 0);
+}
+#endif
+
+#ifdef CONFIG_SPL_EXT_SUPPORT
+static int sata_load_image_ext(const char *filename)
+{
+	int err;
+	struct image_header *header;
+
+	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
+						sizeof(struct image_header));
+	
+	err = ext4_read_file(filename, header, 0, sizeof(struct image_header));
+	if (err <= 0)
+		goto end;
+
+	spl_parse_image_header(header);
+
+	err = ext4_read_file(filename, (u8 *)spl_image.load_addr, 0, 0);
+
+end:
+	if (err <= 0)
+		printf("spl: error reading image %s, err - %d\n",
+		       filename, err);
+	else
+		printf("loading %s from SATA EXT...\n", filename);	
+
+	return (err <= 0);
+}
+#endif
+
+void spl_sata_load_image(void)
+{
+	int err;
+	u32 boot_mode;
+	ulong n;
+
+	err = sata_initialize();
+	if (err) {
+		printf("spl: sata init failed: err - %d\n", err);
+		hang();
+	}
+
+#ifdef CONFIG_SPL_FAT_SUPPORT
+	/* FAT filesystem */
+	err = fat_register_device(&sata_dev_desc[sata_curr_device],
+					  CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
+	if (err) {
+		printf("spl: fat register err - %d\n", err);
+	}
+
+	err = sata_load_image_fat(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME);
+#endif
+
+#ifdef CONFIG_SPL_EXT_SUPPORT
+	/* EXT filesystem */
+	if (err) {
+		disk_partition_t info;
+		if (get_partition_info(&sata_dev_desc[sata_curr_device], CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION, &info)) {
+			printf("Cannot find partition %d\n", CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
+		}		
+		if (ext4fs_probe(&sata_dev_desc[sata_curr_device], &info)) {
+			printf("ext4fs probe failed \n");
+     		}		
+
+		err = sata_load_image_ext(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME);
+	}
+#endif
+	
+	if (err) {
+		printf("Load image from RAW...\n");
+		err = sata_load_image_raw(CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR);
+		if (err) {
+			printf("spl: wrong SATA boot mode\n");
+			hang();
+		}
+	}
+}
diff --git a/include/spl.h b/include/spl.h
index 2bd6e16..b5c6a1d 100644
--- a/include/spl.h
+++ b/include/spl.h
@@ -60,6 +60,9 @@ void spl_spi_load_image(void);
 /* Ethernet SPL functions */
 void spl_net_load_image(const char *device);
 
+/* SATA SPL functions */
+void spl_sata_load_image(void);
+
 #ifdef CONFIG_SPL_BOARD_INIT
 void spl_board_init(void);
 #endif
diff --git a/spl/Makefile b/spl/Makefile
index 5e5472d..8819403 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -64,6 +64,7 @@ LIBS-$(CONFIG_SPL_I2C_SUPPORT) += drivers/i2c/
 LIBS-$(CONFIG_SPL_GPIO_SUPPORT) += drivers/gpio/
 LIBS-$(CONFIG_SPL_MMC_SUPPORT) += drivers/mmc/
 LIBS-$(CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT) += drivers/ddr/fsl/
+LIBS-$(CONFIG_SPL_SATA_SUPPORT) += drivers/block/libblock.o
 LIBS-$(CONFIG_SPL_SERIAL_SUPPORT) += drivers/serial/
 LIBS-$(CONFIG_SPL_SPI_FLASH_SUPPORT) += drivers/mtd/spi/
 LIBS-$(CONFIG_SPL_SPI_SUPPORT) += drivers/spi/
